<?xml version="1.0" encoding="utf-8"?>
<FitData version="10.58" sku="APL" >
    <BuildSettings label="Build Settings">
        <BuildResults label="Image Build Settings">
            <BuildOutputFilename value="bxt_spi_8mb.bin" label="Output Path" />
            <GenIntermediateFiles value="Yes" value_list="No,,Yes" label="Generate Intermediate Files" />
            <BootGrdWrn value="Yes" value_list="No,,Yes" label="Enable Boot Guard warning message at build time" />
            <PTTWrn value="Yes" value_list="No,,Yes" label="Enable Intel (R) Platform Trust Technology warning message at build time" />
            <RegionOrder value="154" label="Region Order" help_text="1=IFWI, 4=PDR, 5=TXE Data" />
            <TargetType value="SPI" value_list="eMMC,,UFS,,SPI" label="Target Type" help_text="Select target type. This setting is configurable from the toolbar." />
            <IfwiBuildVersion value="0x0" help_text="32-bit value to use as the IFWI build version number" />
            <MeuToolPath value="..\MEU\meu.exe" label="Intel(R) Manifest Extension Utility Path" />
            <SigningToolPath value="..\MEU\openssl\openssl.exe" label="Signing Tool Path" />
            <SigningTool value="OpenSSL" value_list="OpenSSL,,MobileSigningUtil" label="Signing Tool" />
            <VerifySigningKeysAgainstOemKeyManifest value="Yes" value_list="No,,Yes" label="Verify manifset signing keys against the OEM Key Manifest." help_text="Indicates whether or not FIT should verify that the OEM Key Manifest contains the hash of the public keys used for signing sub-partitions provided by the OEM." />
        </BuildResults>
        <PathVars label="Environment Variables">
            <WorkingDir value="." label="$WorkingDir" help_text="Path for environment variable $WorkingDir" />
            <SourceDir value="." label="$SourceDir" help_text="Path for environment variable $SourceDir" />
            <DestDir value="." label="$DestDir" help_text="Path for environment variable $DestDir" />
            <UserVar1 value="." label="$UserVar1" help_text="Path for environment variable $UserVar1" />
            <UserVar2 value="." label="$UserVar2" help_text="Path for environment variable $UserVar2" />
            <UserVar3 value="." label="$UserVar3" help_text="Path for environment variable $UserVar3" />
        </PathVars>
    </BuildSettings>
    <FlashLayout label="Flash Layout">
        <SubPartitions>
            <SmipSubPartition label="SMIP Sub-Partition">
                <IaFwSmipInputFile value="$SourceDir\input\smip_iafw.bin" label="IAFW SMIP Binary File" />
            </SmipSubPartition>
            <IunitSubPartition label="IUnit Sub-Partition">
                <InputFile value="" label="IUnit Binary File" help_text="This loads the IUnit binary that will be merged into the output image generated by Intel(R) FIT tool." />
            </IunitSubPartition>
            <PmcSubPartition label="PMC Sub-Partition">
                <InputFile value="$SourceDir\input\pmcp.bin" label="PMC Binary File" help_text="This loads the PMC binary that will be merged into the output image generated by Intel(R) FIT tool." />
            </PmcSubPartition>
            <UCodeSubPartition label="uCode Sub-Partition">
                <UCodePatch1InputFile value="$SourceDir\input\upatch1.bin" label="uCode Patch 1 Input File" help_text="This loads the uCode Patch 1 binary that will be merged into the output image generated by Intel(R) FIT tool." />
                <UCodePatch2InputFile value="" label="uCode Patch 2 Input File" help_text="This loads the uCode Patch 2 binary that will be merged into the output image generated by Intel(R) FIT tool." />
            </UCodeSubPartition>
            <TXESubPartition label="Intel(R) TXE Sub-Partition">
                <InputFile value="$SourceDir\input\cse_image.bin" label="Intel(R) TXE Binary File" help_text="This loads the Intel (R) TXE binary that will be merged into the output image generated by the Intel(R) FIT tool." />
            </TXESubPartition>
            <BiosSubPartition label="IAFW/BIOS Sub-Partition">
                <InputFile value="$SourceDir\input\bios.bin" label="IAFW/BIOS Binary File" help_text="This loads the IAFW/BIOS binary that will be merged into the output image generated by Intel(R) FIT tool." />
                <EnableSplitObb value="Yes" value_list="No,,Yes" label="Enable Split OBB" help_text="OBB's primary location is on BP2, when enabling splitting of the OBB sub-partition, remaining extra OBB portion will be placed in BP1." />
                <BiosDataSize value="512KB" value_list="512KB,,384KB,,256KB,,128KB,,0" label="Bios Data Size" help_text="Configures the BIOS data size in SPI target configurations." />
            </BiosSubPartition>
            <PdrRegion label="SPI PDR Region">
                <Length value="0" />
                <InputFile value="" label="PDR Binary File" help_text="This loads the Platform Data Sub-Partition binary that will be merged into the into the output image generated by the Intel(R) FIT tool." />
                <Enabled value="Disabled" value_list="Disabled,,Enabled" label="PDR Region Enable" help_text="This option allows the user to enable or disable the Platform Data Region. This setting is only applicable for SPI images." />
            </PdrRegion>
        </SubPartitions>
    </FlashLayout>
    <FlashSettings label="Flash Settings">
        <FlashComponents label="Flash Components">
            <NumberOfComponents value="1" value_list="1,,2" label="Number of Flash Components" help_text="Specifies the number of Flash components that will be installed on the target machine if using SPI. For eMMC and UFS, this represents the number of boot partitions and is fixed at 2." />
            <FlashComponent1Size value="8MB" value_list="512KB,,1MB,,2MB,,4MB,,8MB,,16MB,,32MB,,64MB" label="Flash component 1 Size" help_text="This field identifies the size of the 1st Flash component if using SPI. This represents the size of the first boot partition if using eMMC/UFS." />
            <FlashComponent2Size value="8MB" value_list="512KB,,1MB,,2MB,,4MB,,8MB,,16MB,,32MB,,64MB" label="Flash component 2 Size" help_text="This field identifies the size of the 2nd Flash component if using SPI. This represents the size of the second boot partition if using eMMC/UFS and will be equal to the first boot partition size." />
            <BiosRegionOverlap value="false" value_list="true,,false" label="Bios Region Overlap" help_text="Overlap Bios and ME regions in SPI mode." />
        </FlashComponents>
        <BootSourceSelection label="Boot Source Selection">
            <SpiBootSourceEnabled value="Enabled" value_list="Enabled,,Disabled" label="SPI Boot Source Enable/Disable" help_text="Permanent Enable/Disable SPI Boot Device FPF" />
            <UfsBootSourceEnabled value="Disabled" value_list="Enabled,,Disabled" label="UFS Boot Source Enable/Disable" help_text="Permanent Enable/Disable UFS Boot Device FPF" />
            <EmmcBootSourceEnabled value="Disabled" value_list="Enabled,,Disabled" label="eMMc Boot Source Enable/Disable" help_text="Permanent Enable/Disable eMMc Boot Device FPF" />
        </BootSourceSelection>
        <UfsSettings label="UFS Settings">
            <UfsPhyBinary value="" label="UFS Phy Init Binary" help_text="UFS PHY Binary sub-partiion. Maximum size is 1 KB" />
            <UfsGppLunEnabled value="Disabled" value_list="Disabled,,Enabled" label="UFS GPP LUN Enable" help_text="Set to 'Enabled' to enable UFS GPP LUN Sub-Partition" />
            <UfsGppLunId value="6" value_list="0,,1,,2,,3,,4,,5,,6,,7" label="UFS GPP LUN ID" help_text="The UFS GPP LUN ID is a single byte value stored in the UFS GPP LUN Sub-Partition" />
        </UfsSettings>
        <HostCpuBiosMasterAccess label="Host CPU / BIOS Master Access">
            <HostCpuWriteAccess value="0xFFF" value_list="0xFFF,,0x002,,0x012,,Custom" label="Host CPU / BIOS Write Access" help_text="This setting determines write access control for the Host CPU / BIOS.  For further details on Region Access Control see the SPI and SMIP Programming Guide" />
            <HostCpuWriteAccessCustom value="0x0" label="Host CPU / BIOS Write Access Custom" help_text="This setting determines write access control for the Host CPU / BIOS.  For further details on Region Access Control see the SPI and SMIP Programming Guide" />
            <HostCpuReadAccess value="0xFFF" value_list="0xFFF,,0x003,,0x013,,Custom" label="Host CPU / BIOS Read Access" help_text="This setting determines read access control for the Host CPU / BIOS.  For further details on Region Access Control see the SPI and SMIP Programming Guide" />
            <HostCpuReadAccessCustom value="0x0" label="Host CPU / BIOS Read Access Custom" help_text="This setting determines read access control for the Host CPU / BIOS.  For further details on Region Access Control see the SPI and SMIP Programming Guide" />
        </HostCpuBiosMasterAccess>
        <IntelTxeMasterAccess label="Intel(R) TXE Master Access">
            <TxeWriteAccess value="0xFFF" value_list="0xFFF,,0x024,,Custom" label="Intel(R) TXE Write Access" help_text="This setting determines write access control for the TXE.  For further details on Region Access Control see the SPI and SMIP Programming Guide" />
            <TxeWriteAccessCustom value="0x0" label="Intel(R) TXE Write Access Custom" help_text="This setting determines write access control for the TXE.  For further details on Region Access Control see the SPI and SMIP Programming Guide" />
            <TxeReadAccess value="0xFFF" value_list="0xFFF,,0x027,,Custom" label="Intel(R) TXE Read Access" help_text="This setting determines read access control for the TXE.  For further details on Region Access Control see the SPI and SMIP Programming Guide" />
            <TxeReadAccessCustom value="0x0" label="Intel(R) TXE Read Access Custom" help_text="This setting determines read access control for the TXE.  For further details on Region Access Control see the SPI and SMIP Programming Guide" />
        </IntelTxeMasterAccess>
        <FlashConfiguration label="Flash Configuration">
            <BootBlockSize value="64KB" value_list="64KB,,128KB,,256KB,,512KB,,1MB" label="Boot Block Size" help_text="This soft strap only applies when booting from SPI. Boot from LPC (FWH) only supports a 64KB boot block size (Invert A16) and this soft strap value is a don't care. Note No bits are inverted if a Reserved encoding is programmed." />
            <SpiDualIoReadEnable value="Yes" value_list="No,,Yes" label="Dual I/O Read Enable" help_text="This soft-strap only has effect if Dual I/O Read is discovered as supported via the SFDP." />
            <DualOutFastReadSupport value="No" value_list="No,,Yes" label="Dual Output Fast Read Supported" help_text="This setting allows customers to configure if Dual Output Fast Read is supported. See SPI and SMIP Programming guide further details." />
            <SpiDualOutReadEnable value="No" value_list="No,,Yes" label="Dual Output Read Enable" help_text="This soft-strap only has effect if Dual Output Read is discovered as supported via the SFDP. If parameter table is not detected via the SFDP, this bit has no effect and Dual Output Read is controlled via the Flash Descriptor.Component Section.Dual Output Fast Read Support bit." />
            <FastReadClockFreq value="50MHz" value_list="50MHz,,40MHz,,25MHz" label="Fast Read Clock Frequency" help_text="This setting allows customers to configure the flash component clock frequency setting for Fast Read. See SPI and SMIP Programming guide further details." />
            <FastReadSupport value="Yes" value_list="No,,Yes" label="Fast Read Supported" help_text="This setting allows customers to enable support for Fast Read capabilities for flash components. See SPI and SMIP Programming guide further details. Note: This setting needs to be enabled when using Dual / Quad enabled components." />
            <InvalidInstruction0 value="0x00000021" label="Invalid Instruction 0" help_text="This setting allows customers to configure invalid instruction to protect against Chip Erase. Note: This setting should be set to '0' if there are not Invalid instructions." />
            <InvalidInstruction1 value="0x00000042" label="Invalid Instruction 1" help_text="This setting allows customers to configure invalid instruction to protect against Chip Erase. Note: This setting should be set to '0' if there are not Invalid instructions." />
            <InvalidInstruction2 value="0x00000060" label="Invalid Instruction 2" help_text="This setting allows customers to configure invalid instruction to protect against Chip Erase. Note: This setting should be set to '0' if there are not Invalid instructions." />
            <InvalidInstruction3 value="0x000000AD" label="Invalid Instruction 3" help_text="This setting allows customers to configure invalid instruction to protect against Chip Erase. Note: This setting should be set to '0' if there are not Invalid instructions." />
            <InvalidInstruction4 value="0x000000B7" label="Invalid Instruction 4" help_text="This setting allows customers to configure invalid instruction to protect against Chip Erase. Note: This setting should be set to '0' if there are not Invalid instructions." />
            <InvalidInstruction5 value="0x000000B9" label="Invalid Instruction 5" help_text="This setting allows customers to configure invalid instruction to protect against Chip Erase. Note: This setting should be set to '0' if there are not Invalid instructions." />
            <InvalidInstruction6 value="0x000000C4" label="Invalid Instruction 6" help_text="This setting allows customers to configure invalid instruction to protect against Chip Erase. Note: This setting should be set to '0' if there are not Invalid instructions." />
            <InvalidInstruction7 value="0x000000C7" label="Invalid Instruction 7" help_text="This setting allows customers to configure invalid instruction to protect against Chip Erase. Note: This setting should be set to '0' if there are not Invalid instructions." />
            <PrrTopSwapOverride value="No" value_list="No,,Yes" label="Protected Range and Top Swap Override" help_text="For more information, see SPI and SMIP Programming Guide" />
            <QuadIoReadEnable value="No" value_list="No,,Yes" label="Quad I/O Read Enable" help_text="This soft-strap only has effect if Quad I/O Read is discovered as supported via the SFDP." />
            <QuadOutReadEnable value="Yes" value_list="No,,Yes" label="Quad Output Read Enable" help_text="This soft-strap only has effect if Quad Output Read is discovered as supported via the SFDP." />
            <ReadIdAndReadStatClkFreq value="25MHz" value_list="50MHz,,40MHz,,25MHz" label="Read ID and Read Status Clock Frequency" help_text="This setting allows customers to configure the flash component clock frequency setting for Read ID and Read Status. See SPI and SMIP Programming guide further details." />
            <SpiStopPrefetchonFlushPending value="No" value_list="No,,Yes" label="SPI Stop Prefetch on Flush Pending" help_text="This soft-strap determines the reset t value of the BIOS Flash Program Register AFC.SPFP bit." />
            <SpiHostSwSequencingEnableDefault value="No" value_list="No,,Yes" label="SPI Host Software Sequencing Enable Default" help_text="This strap sets the default value of the CSME ICE.HSSEN register." />
            <SpiEnableDevice0DeepPowerdown value="No" value_list="No,,Yes" label="SPI Enable Device 0 Deep Powerdown" />
            <SpiEnableDevice1DeepPowerdown value="No" value_list="No,,Yes" label="SPI Enable Device 1 Deep Powerdown" />
            <SpiDelayBeforeRPMCBusyPollEnable value="No" value_list="No,,Yes" label="SPI Enable Delay before RPMC busy poll" />
            <SpiDelayBeforeEraseBusyPollEnable value="No" value_list="No,,Yes" label="SPI Enable Delay before erase busy poll" />
            <SpiDelayBeforeWriteBusyPollEnable value="No" value_list="No,,Yes" label="SPI Enable Delay before write busy poll" />
            <SpiIdletoDeepPowerDownTimeoutDefault value="0x00000005" label="SPI Idle to Deep Power Down Timeout Default" help_text="Specifies the time in microseconds that the Flash Controller waits after all activity is idle before commanding the flash devices to Deep Powerdown. Max is 2^15 = 32768." />
            <WriteEraseClockFreq value="25MHz" value_list="50MHz,,40MHz,,25MHz" label="Write and Erase Clock Frequency" help_text="This setting allows customers to configure the flash component clock frequency setting for  Write and Erase. See SPI and SMIP Programming guide further details." />
            <WriteProtectionEnable value="No" value_list="No,,Yes" label="Write Protection Enable" help_text="Base/limit are inclusive" />
            <ProtectedRangeLimit value="0x00000000" label="Protected Range Limit" help_text="This field corresponds to FLA (Flash Linear Address) address bits 26:12 and specifies the upper limit of the protected range. Address bits 11:0 are assumed to be FFFh for the limit comparison. Any address greater than the value programmed in this field is unaffected by this protected range. Note: If either Write or Read protection is enabled, then Limit must be configured greater than or equal to Base.  See SPI and SMIP Programming Guide for more information." />
            <ReadProtectionEnable value="No" value_list="No,,Yes" label="Read Protection Enable" help_text="Base/limit are inclusive" />
            <ProtectedRangeBase value="0x00000000" label="Protected Range Base" help_text="This field corresponds to FLA (Flash Linear Address) address bits 26:12 and specifies the lower base of the protected range. Address bits 11:0 are assumed to be 000h for the base comparison. Any address less than the value programmed in this field is unaffected by this protected range. Note: Note: If either Write or Read protection is enabled, then Limit must be configured greater than or equal to Base. See SPI and SMIP Programming Guide for more details." />
        </FlashConfiguration>
        <VsccTable label="VSCC Table">
            <VsccEntries label="VSCC Entries">
                <VsccEntry label="VSCC Entry">
                    <VsccEntryName value="W25Q128FW" label="Part Name" />
                    <VsccEntryVendorId value="0xEF" label="Vendor ID" />
                    <VsccEntryDeviceId0 value="0x60" label="Device ID 0" />
                    <VsccEntryDeviceId1 value="0x18" label="Device ID 1" />
                </VsccEntry>
            </VsccEntries>
        </VsccTable>
    </FlashSettings>
    <CpuStraps label="CPU Straps">
        <PUnit label="PUNIT">
            <ThermalThrottleUnlock value="Locked" value_list="Locked,,Unlocked" label="Thermal Throttle Unlock" help_text="See SPI and SMIP Programming Guide for more information" />
            <ExtendedReliabilityEnable value="Disabled" value_list="Disabled,,Enabled" label="Extended Reliability Enable" help_text="See SPI and SMIP Programming Guide for more information" />
            <SoftSvidEnable value="Enabled" value_list="Enabled,,Disabled" label="Soft SVID Enable" help_text="See SPI and SMIP Programming Guide for more information" />
            <Rail0AlertPollEnable value="Enabled" value_list="Disabled,,Enabled" label="Rail 0 Alert Polling Enable" help_text="This bit defines whether the STATUS1 register for Rail 0 must be polled on Alert# assertions or not." />
            <Rail0SvidId value="0x00000000" label="Rail 0 SVID ID" help_text="This contains the PMIC Rail ID for SVID Rail 0, i.e. Vccgi. PCODE uses this to program the SVID_RAIL0_CONFIG_AND_STATUS register during reset." />
            <Rail1AlertPollEnable value="Enabled" value_list="Disabled,,Enabled" label="Rail 1 Alert Polling Enable" help_text="This bit defines whether the STATUS1 register for Rail 1 must be polled on Alert# assertions or not." />
            <Rail1SvidId value="0x00000002" label="Rail 1 SVID ID" help_text="This contains the PMIC Rail ID for SVID Rail 1, aka Vnn. PCODE uses this to program the SVID_RAIL1_CONFIG_AND_STATUS register during reset." />
            <Rail2AlertPollEnable value="Disabled" value_list="Disabled,,Enabled" label="Rail 2 Alert Polling Enable" help_text="This bit defines whether the STATUS1 register for Rail 2 must be polled on Alert# assertions or not." />
            <Rail2SvidId value="0x00000002" label="Rail 2 SVID ID" help_text="This contains the PMIC Rail ID for SVID Rail 2. PCODE uses this to program the SVID_RAIL2_CONFIG_AND_STATUS register during reset." />
            <Rail3AlertPollEnable value="Disabled" value_list="Disabled,,Enabled" label="Rail 3 Alert Polling Enable" help_text="This bit defines whether the STATUS1 register for Rail 3 must be polled on Alert# assertions or not" />
            <Rail3SvidId value="0x00000006" label="Rail 3 SVID ID" help_text="This contains the PMIC Rail ID for SVID Rail 3. PCODE uses this to program the SVID_RAIL3_CONFIG_AND_STATUS register during reset" />
        </PUnit>
    </CpuStraps>
    <FlexIo label="Flex I/O">
        <ModPhyLaneConfiguration>
            <ModPhyLane2 value="PCIe" value_list="USB3,,PCIe" />
            <ModPhyLane3 value="PCIe" value_list="USB3,,PCIe" />
            <ModPhyLane4 value="USB3" value_list="USB3,,PCIe" />
            <ModPhyLane8 value="USB3" value_list="USB3,,SATA" />
        </ModPhyLaneConfiguration>
        <UsbX label="USBx">
            <Usb3SsicPort1Ownership value="USB3" value_list="USB3,,SSIC" label="USB3/SSIC Port 1 Ownership" help_text="See SPI and SMIP Programming Guide for more information" />
            <Usb3SsicPort2Ownership value="USB3" value_list="USB3,,SSIC" label="USB3/SSIC Port 2 Ownership" help_text="See SPI and SMIP Programming Guide for more information" />
            <Usb3SsicPort3Ownership value="USB3" value_list="USB3,,SSIC" label="USB3/SSIC Port 3 Ownership" help_text="See SPI and SMIP Programming Guide for more information" />
            <Usb3SsicPort4Ownership value="USB3" value_list="USB3,,SSIC" label="USB3/SSIC Port 4 Ownership" help_text="See SPI and SMIP Programming Guide for more information" />
            <Usb3SsicPort5Ownership value="USB3" value_list="USB3,,SSIC" label="USB3/SSIC Port 5 Ownership" help_text="See SPI and SMIP Programming Guide for more information" />
            <Usb3SsicPort6Ownership value="USB3" value_list="USB3,,SSIC" label="USB3/SSIC Port 6 Ownership" help_text="See SPI and SMIP Programming Guide for more information" />
            <Usb3SsicPort7Ownership value="USB3" value_list="USB3,,SSIC" label="USB3/SSIC Port 7 Ownership" help_text="See SPI and SMIP Programming Guide for more information" />
        </UsbX>
        <Exi label="EXI">
            <Usb3SsicComboPort1 value="USB3" value_list="USB3,,SSIC" label="USB3/SSIC Combo Port 1" help_text="See SPI and SMIP Programming Guide for more information" />
            <Usb3SsicComboPort2 value="USB3" value_list="USB3,,SSIC" label="USB3/SSIC Combo Port 2" help_text="See SPI and SMIP Programming Guide for more information" />
            <UfsComboPort0 value="non-UFS" value_list="non-UFS,,UFS" label="UFS Combo Port 0" help_text="See SPI and SMIP Programming Guide for more information" />
            <PcieUsb3ComboPort0 value="USB3" value_list="USB3,,PCIe" label="PCIe/USB3 Combo Port 0" help_text="See SPI and SMIP Programming Guide for more information" />
            <PcieUsb3ComboPort1 value="USB3" value_list="USB3,,PCIe" label="PCIe/USB3 Combo Port 1" help_text="See SPI and SMIP Programming Guide for more information" />
            <PcieUsb3ComboPort2 value="USB3" value_list="USB3,,PCIe" label="PCIe/USB3 Combo Port 2" help_text="See SPI and SMIP Programming Guide for more information" />
            <PcieUsb3ComboPort3 value="USB3" value_list="USB3,,PCIe" label="PCIe/USB3 Combo Port 3" help_text="See SPI and SMIP Programming Guide for more information" />
        </Exi>
        <Fia label="FIA">
            <StaggeringEnable value="Enabled" value_list="Disabled,,Enabled" label="Staggering Enable" help_text="See SPI and SMIP Programming Guide for more information" />
        </Fia>
        <PcieX2 label="PCIe (x2)">
            <PcieRootPortConfig value="2x1" value_list="2x1,,1x2" label="Root Port Configuration (RPCFG)" />
            <PcieLaneReversal value="No" value_list="No,,Yes" label="Lane Reversal (LNREV)" />
            <PciePort0NonCmnClockSscMode value="Disabled" value_list="Disabled,,Enabled" label="PCIe Port 0 Non-Common Clock With SSC Mode Enable" help_text="See SPI and SMIP Programming Guide for more information" />
            <PciePort1NonCmnClockSscMode value="Disabled" value_list="Disabled,,Enabled" label="PCIe Port 1 Non-Common Clock With SSC Mode Enable" help_text="See SPI and SMIP Programming Guide for more information" />
            <PciePort2NonCmnClockSscMode value="Disabled" value_list="Disabled,,Enabled" label="PCIe Port 2 Non-Common Clock With SSC Mode Enable" help_text="See SPI and SMIP Programming Guide for more information" />
            <PciePort3NonCmnClockSscMode value="Disabled" value_list="Disabled,,Enabled" label="PCIe Port 3 Non-Common Clock With SSC Mode Enable" help_text="See SPI and SMIP Programming Guide for more information" />
        </PcieX2>
        <PcieX4 label="PCIe (x4)">
            <PcieRootPortConfig value="1x22x1" value_list="4x1,,1x22x1,,2x2,,1x4" label="Root Port Configuration (RPCFG)" />
            <PcieLaneReversal value="No" value_list="No,,Yes" label="Lane Reversal (LNREV)" />
            <PciePort4NonCmnClockSscMode value="Disabled" value_list="Disabled,,Enabled" label="PCIe Port 4 Non-Common Clock With SSC Mode Enable" help_text="See SPI and SMIP Programming Guide for more information" />
            <PciePort5NonCmnClockSscMode value="Disabled" value_list="Disabled,,Enabled" label="PCIe Port 5 Non-Common Clock With SSC Mode Enable" help_text="See SPI and SMIP Programming Guide for more information" />
        </PcieX4>
        <Sata label="SATA">
            <MPhyLaneSataPort0 value="SATA" value_list="SATA,,PCIe,,GPIO" label="Mod-PHY lane SATA Port 0" help_text="See SPI and SMIP Programming Guide for more information" />
            <MPhyLaneSataPort2 value="SATA" value_list="SATA,,PCIe,,GPIO" label="Mod-PHY lane SATA Port 2" help_text="See SPI and SMIP Programming Guide for more information" />
            <MPhyLaneSataPort3 value="SATA" value_list="SATA,,PCIe,,GPIO" label="Mod-PHY lane SATA Port 3" help_text="See SPI and SMIP Programming Guide for more information" />
            <MPhyLaneSataPort4 value="SATA" value_list="SATA,,PCIe,,GPIO" label="Mod-PHY lane SATA Port 4" help_text="See SPI and SMIP Programming Guide for more information" />
            <MPhyLaneSataPort5 value="SATA" value_list="SATA,,PCIe,,GPIO" label="Mod-PHY lane SATA Port 5" help_text="See SPI and SMIP Programming Guide for more information" />
            <MPhyLaneSataPort6 value="SATA" value_list="SATA,,PCIe,,GPIO" label="Mod-PHY lane SATA Port 6" help_text="See SPI and SMIP Programming Guide for more information" />
            <MPhyLaneSataPort7 value="SATA" value_list="SATA,,PCIe,,GPIO" label="Mod-PHY lane SATA Port 7" help_text="See SPI and SMIP Programming Guide for more information" />
            <SataPcieGpioPolarityPort0 value="0 = PCIe" value_list="0 = PCIe,,0 = SATA" label="SATA/PCIe Select GPIO polarity for SATA Port 0" help_text="See SPI and SMIP Programming Guide for more information" />
            <SataPcieGpioPolarityPort1 value="0 = PCIe" value_list="0 = PCIe,,0 = SATA" label="SATA/PCIe Select GPIO polarity for SATA Port 1" help_text="See SPI and SMIP Programming Guide for more information" />
            <SataPcieGpioPolarityPort2 value="0 = PCIe" value_list="0 = PCIe,,0 = SATA" label="SATA/PCIe Select GPIO polarity for SATA Port 2" help_text="See SPI and SMIP Programming Guide for more information" />
            <SataPcieGpioPolarityPort3 value="0 = PCIe" value_list="0 = PCIe,,0 = SATA" label="SATA/PCIe Select GPIO polarity for SATA Port 3" help_text="See SPI and SMIP Programming Guide for more information" />
            <SataPcieGpioPolarityPort4 value="0 = PCIe" value_list="0 = PCIe,,0 = SATA" label="SATA/PCIe Select GPIO polarity for SATA Port 4" help_text="See SPI and SMIP Programming Guide for more information" />
            <SataPcieGpioPolarityPort5 value="0 = PCIe" value_list="0 = PCIe,,0 = SATA" label="SATA/PCIe Select GPIO polarity for SATA Port 5" help_text="See SPI and SMIP Programming Guide for more information" />
            <SataPcieGpioPolarityPort6 value="0 = PCIe" value_list="0 = PCIe,,0 = SATA" label="SATA/PCIe Select GPIO polarity for SATA Port 6" help_text="See SPI and SMIP Programming Guide for more information" />
            <SataPcieGpioPolarityPort7 value="0 = PCIe" value_list="0 = PCIe,,0 = SATA" label="SATA/PCIe Select GPIO polarity for SATA Port 7" help_text="See SPI and SMIP Programming Guide for more information" />
        </Sata>
    </FlexIo>
    <PlatformConfiguration label="Platform Configuration">
        <PmicVrConfig value="SVID VR - Discrete SVID" value_list="SVID VR - Discrete SVID,,I2C VR - TI TPS650941,,I2C VR - RT DS5074A,,I2C VR - Rohm BD2670MVW" label="PMIC/VR Configuration" help_text="These are the supported VR types for BXT-P SOC. Intel FW only supports this BOM list." />
        <PrtcBackupPower value="Exists" value_list="None,,Exists" label="Persistent PRTC Backup Power" help_text="FPF that indicates if the device is designed such that it may lose PRTC power more than 10 times throughout the normal lifecycle of the product and hence has no persistent time or AR protection. At EOM, this value is burned to an FPF, and can never be changed" />
        <SMIP_VERSION_CATEGORY label="SMIP Version Config">
            <PMC_OEM_SMIP_VERSION.MAJOR_VERSION value="0x00" help_text="Version information for the PMC OEM SMIP. Used internally by PMC FW team to communicate which SMIP version is in use. OEMs and other users of the SMIP can use this field to identify a version. " />
            <PMC_OEM_SMIP_VERSION.CONFIG_VERSION value="0x00" help_text="Version information for the PMC OEM SMIP. Used internally by PMC FW team to communicate which SMIP version is in use. OEMs and other users of the SMIP can use this field to identify a version. " />
            <PMC_OEM_SMIP_VERSION.MINOR_VERSION value="0x00" help_text="Version information for the PMC OEM SMIP. Used internally by PMC FW team to communicate which SMIP version is in use. OEMs and other users of the SMIP can use this field to identify a version. " />
            <PMC_OEM_SMIP_VERSION.ENGR_VERSION value="0x00" help_text="Version information for the PMC OEM SMIP. Used internally by PMC FW team to communicate which SMIP version is in use. OEMs and other users of the SMIP can use this field to identify a version. " />
        </SMIP_VERSION_CATEGORY>
        <I2CVR_CATEGORY label="I2C VR Config">
            <IAI2CVRRdWrInValidAddrRange_0.IAI2CVRRdWrInValidAddrRange_0 value="0x5E275E00" help_text="This field only applicable and programmable if there is an I2C VR attached on the platform. Note that there are 32 of these such registers, IAI2CVRRdWrInValidAddrRange[32:0]. List of register ranges in I2C voltage regulator which are subject to write access control. I2CVR addressing utilizes 2 bytes: MSB (byte 1) is base address; LSB (byte 0) is the offset. The range is from bits[15:0] to bits [31:16]. For example, value 0x56781234 would indicate I2CVR base address 0x12, offset 0x34 to I2CVR base address 0x56, offset 0x78 are inaccessible.. " />
            <IAI2CVRRdWrInValidAddrRange_1.IAI2CVRRdWrInValidAddrRange_1 value="0x00000000" help_text="List of register ranges in I2C voltage regulator which are subject to write access control. I2CVR addressing utilizes 2 bytes: MSB (byte 1) is base address; LSB (byte 0) is the offset. The range is from bits[15:0] to bits [31:16]. For example, value 0x56781234 would indicate I2CVR base address 0x12, offset 0x34 to I2CVR base address 0x56, offset 0x78 are inaccessible.. " />
            <IAI2CVRRdWrInValidAddrRange_2.IAI2CVRRdWrInValidAddrRange_2 value="0x00000000" help_text="List of register ranges in I2C voltage regulator which are subject to write access control. I2CVR addressing utilizes 2 bytes: MSB (byte 1) is base address; LSB (byte 0) is the offset. The range is from bits[15:0] to bits [31:16]. For example, value 0x56781234 would indicate I2CVR base address 0x12, offset 0x34 to I2CVR base address 0x56, offset 0x78 are inaccessible.. " />
            <IAI2CVRRdWrInValidAddrRange_3.IAI2CVRRdWrInValidAddrRange_3 value="0x00000000" help_text="List of register ranges in I2C voltage regulator which are subject to write access control. I2CVR addressing utilizes 2 bytes: MSB (byte 1) is base address; LSB (byte 0) is the offset. The range is from bits[15:0] to bits [31:16]. For example, value 0x56781234 would indicate I2CVR base address 0x12, offset 0x34 to I2CVR base address 0x56, offset 0x78 are inaccessible.. " />
            <IAI2CVRRdWrInValidAddrRange_4.IAI2CVRRdWrInValidAddrRange_4 value="0x00000000" help_text="List of register ranges in I2C voltage regulator which are subject to write access control. I2CVR addressing utilizes 2 bytes: MSB (byte 1) is base address; LSB (byte 0) is the offset. The range is from bits[15:0] to bits [31:16]. For example, value 0x56781234 would indicate I2CVR base address 0x12, offset 0x34 to I2CVR base address 0x56, offset 0x78 are inaccessible.. " />
            <IAI2CVRRdWrInValidAddrRange_5.IAI2CVRRdWrInValidAddrRange_5 value="0x00000000" help_text="List of register ranges in I2C voltage regulator which are subject to write access control. I2CVR addressing utilizes 2 bytes: MSB (byte 1) is base address; LSB (byte 0) is the offset. The range is from bits[15:0] to bits [31:16]. For example, value 0x56781234 would indicate I2CVR base address 0x12, offset 0x34 to I2CVR base address 0x56, offset 0x78 are inaccessible.. " />
            <IAI2CVRRdWrInValidAddrRange_6.IAI2CVRRdWrInValidAddrRange_6 value="0x00000000" help_text="List of register ranges in I2C voltage regulator which are subject to write access control. I2CVR addressing utilizes 2 bytes: MSB (byte 1) is base address; LSB (byte 0) is the offset. The range is from bits[15:0] to bits [31:16]. For example, value 0x56781234 would indicate I2CVR base address 0x12, offset 0x34 to I2CVR base address 0x56, offset 0x78 are inaccessible.. " />
            <IAI2CVRRdWrInValidAddrRange_7.IAI2CVRRdWrInValidAddrRange_7 value="0x00000000" help_text="List of register ranges in I2C voltage regulator which are subject to write access control. I2CVR addressing utilizes 2 bytes: MSB (byte 1) is base address; LSB (byte 0) is the offset. The range is from bits[15:0] to bits [31:16]. For example, value 0x56781234 would indicate I2CVR base address 0x12, offset 0x34 to I2CVR base address 0x56, offset 0x78 are inaccessible.. " />
        </I2CVR_CATEGORY>
        <PLL_CATEGORY label="LJ1PLL and LCPLL Config">
            <LJ1PLL_SETTINGS_FORCE_COLD_RESET.LJ1PLL_SETTINGS_FORCE_COLD_RESET value="DISABLE" value_list="DISABLE,,ENABLE" help_text="LJ1PLL settings will force a cold reset when this is non-zero. Normal usage is to force a cold reset (assert this bit) if changes to LJ1PLL are desired, otherwise BIOS is expected to cause a cold reset for LJ1PLL changes to take effect." />
            <LJ1PLL_RW_CONTROL_1_DEFAULT.SSC_EN value="DISABLE" value_list="DISABLE,,ENABLE" help_text="LJ1PLL_RW_CONTROL_1 register default value to be programmed during boot. " />
            <LJ1PLL_RW_CONTROL_1_DEFAULT.SSC_EN_OVR value="DISABLE_OVERRIDE" value_list="DISABLE_OVERRIDE,,ENABLE_OVERRIDE" help_text="LJ1PLL_RW_CONTROL_1 register default value to be programmed during boot. " />
            <LJ1PLL_RW_CONTROL_2_DEFAULT.SSC_FRAC_STEP value="0x07D9C" help_text="LJ1PLL_RW_CONTROL_2 register default value to be programmed during boot. " />
            <LJ1PLL_RW_CONTROL_2_DEFAULT.SSC_MODE value="DOWN_SPREAD_ONLY" value_list="DOWN_SPREAD_ONLY,,UP_SPREAD_ONLY,,CENTER_SPREAD_START_W_DOWN_SPREAD,,CENTER_SPREAD_START_W_UP_SPREAD" help_text="LJ1PLL_RW_CONTROL_2 register default value to be programmed during boot. " />
            <LJ1PLL_RW_CONTROL_2_DEFAULT.SSC_CYC_TO_PEAK_M1 value="0x12B" help_text="LJ1PLL_RW_CONTROL_2 register default value to be programmed during boot. " />
            <LJ1PLL_RW_CONTROL_5_DEFAULT.PLL_RATIO_INT value="0x7D" help_text="LJ1PLL_RW_CONTROL_5 register default value to be programmed during boot. " />
            <LJ1PLL_RW_CONTROL_5_DEFAULT.PLL_RATIO_FRAC value="0x000000" help_text="LJ1PLL_RW_CONTROL_5 register default value to be programmed during boot. " />
            <LCPLL_RW_CONTROL_1_DEFAULT.SSC_EN value="DISABLE" value_list="DISABLE,,ENABLE" help_text="LCPLL_RW_CONTROL_1 register default value to be programmed during boot - highly recommended not to change these fields as they are related to high-speed IOs. " />
            <LCPLL_RW_CONTROL_1_DEFAULT.SSC_EN_OVR value="DISABLE_OVERRIDE" value_list="DISABLE_OVERRIDE,,ENABLE_OVERRIDE" help_text="LCPLL_RW_CONTROL_1 register default value to be programmed during boot - highly recommended not to change these fields as they are related to high-speed IOs. " />
            <LCPLL_RW_CONTROL_2_DEFAULT.SSC_FRAC_STEP value="0x07D9C" help_text="LCPLL_RW_CONTROL_2 register default value to be programmed during boot - highly recommended not to change these fields as they are related to high-speed IOs. " />
            <LCPLL_RW_CONTROL_2_DEFAULT.SSC_MODE value="DOWN_SPREAD_ONLY" value_list="DOWN_SPREAD_ONLY,,UP_SPREAD_ONLY,,CENTER_SPREAD_START_W_DOWN_SPREAD,,CENTER_SPREAD_START_W_UP_SPREAD" help_text="LCPLL_RW_CONTROL_2 register default value to be programmed during boot - highly recommended not to change these fields as they are related to high-speed IOs. " />
            <LCPLL_RW_CONTROL_2_DEFAULT.SSC_CYC_TO_PEAK_M1 value="0x12B" help_text="LCPLL_RW_CONTROL_2 register default value to be programmed during boot - highly recommended not to change these fields as they are related to high-speed IOs. " />
        </PLL_CATEGORY>
        <MISC_CATEGORY label="MISC Config">
            <TCO_NO_REBOOT.TCO_NO_REBOOT value="REBOOT" value_list="REBOOT,,NO_REBOOT" help_text="GCR.PMC_CFG.NO_REBOOT configuration. 1'b0 = reboot, 1'b1 = no_reboot. Disabling of TCO_NO_REBOOT is required for resetbreak to occur when handling reset from TCO source.. TCO is a software-controlled platform-level watchdog timer" />
            <RESETBUTTON_DEBOUNCE_DIS.RESETBUTTON_DEBOUNCE_DIS value="ENABLE_DEBOUNCE" value_list="ENABLE_DEBOUNCE,,DISABLE_DEBOUNCE" help_text="Value to be programmed for the HW bit to disable the reset button debounce circuit. Debounce the circuit may be required depending on reset button hardware" />
            <S0IX_VR_RAMP_TIMER.S0IX_VR_RAMP_TIMER value="0xA0" help_text="Default value to write to VNNAON_LDO_CTL.S0IX_VR_RAMP_TIMER PMU register field. RTC clock timer value for Vnn/Vccram rail ramp during S0ix exit. The default value of 0hA0 corresponds to 5.12 ms. A value of 0x01 would correspond to 32 us. 0x01: 32 us, 0x02: 64 us, 0xA0: 5.12 ms. Precision is 32e-6.. " />
            <MISC_PMC_ENABLE.ALLOW_I2C_CONNECTION_WITH_SVID value="DO_NOT_ALLOW_I2C_CONNECTION_WITH_SVID" value_list="DO_NOT_ALLOW_I2C_CONNECTION_WITH_SVID,,ALLOW_I2C_CONNECTION_WITH_SVID" help_text="PMC Feature enable bits. " />
            <MISC_PMC_ENABLE.FUNC_DIS_RTC_SAVE_ENABLE value="DISABLE_FUNC_DIS_RTC_SAVE" value_list="DISABLE_FUNC_DIS_RTC_SAVE,,ENABLE_FUNC_DIS_RTC_SAVE" help_text="PMC Feature enable bits. " />
            <USB_AUXCLK_GATING_S0IX_OVRD.USB_AUXCLK_GATING_S0IX_OVRD value="OVERRIDE_DISABLE" value_list="OVERRIDE_DISABLE,,OVERRIDE_ENABLE" help_text="Enable USB aux clk gating during Sx/S0ix entry by setting the override to 1, disabled by default. An OEM would use these bit to declare that all USB2 ports are disconnected, or unpowered in SX or S0ix, or both in their closed/controlled system. If an OEM is sure that the USB bus implementation (devices and hubs) on their platforms can tolerate a resume rebroadcast/reflection from the host(SoC) that is longer than the spec requirement of 1ms (up to ~1.5ms) then they can set the overrides so that USB aux clk gating is always enabled on entry to Sx/S0ix. The spec timing that is POTENTIALLY being violated here is: TURSM (Time from detecting downstream resume to rebroadcast): 1.0 ms max (no min specified) USB2.0 spec, Section 7.1.7.7 . Override for always enabling USB AUX Clock Gating during S0ix" />
            <USB_AUXCLK_GATING_SX_OVRD.USB_AUXCLK_GATING_SX_OVRD value="OVERRIDE_DISABLE" value_list="OVERRIDE_DISABLE,,OVERRIDE_ENABLE" help_text="Enable USB aux clk gating during Sx/S0ix entry by setting the override to 1, disabled by default. An OEM would use these bit to declare that all USB2 ports are disconnected, or unpowered in SX or S0ix, or both in their closed/controlled system. If an OEM is sure that the USB bus implementation (devices and hubs) on their platforms can tolerate a resume rebroadcast/reflection from the host(SoC) that is longer than the spec requirement of 1ms (up to ~1.5ms) then they can set the overrides so that USB aux clk gating is always enabled on entry to Sx/S0ix. The spec timing that is POTENTIALLY being violated here is: TURSM (Time from detecting downstream resume to rebroadcast): 1.0 ms max (no min specified) USB2.0 spec, Section 7.1.7.7 . Override for always enabling USB AUX Clock Gating during Sx" />
            <SUS_STAT_DEASSERT_TIME.SUS_STAT_DEASSERT_TIME value="0x00000000" help_text="Minimum time guaranteed to be elapsed before SUS_STAT deassertion. Note this feature not available in BXTp-A0; available BXTp-B0 and beyond.. Note this feature not available in BXTp-A0; available BXTp-B0 and beyond." />
        </MISC_CATEGORY>
        <WHISKEYCOVE_CATEGORY label="Whiskey Cove Config">
            <IASecureRdWrInValidAddrRange_0.IASecureRdWrInValidAddrRange_0 value="0x4E924E92" help_text="Note that there are 32 of these such registers, IASecureRdWrInvalidAddrRange[32:0]. Secure PMIC Black list Registers for HOST. List of register ranges in PMIC which are subject to write access control. Host does NOT have access to these registers when Secure. PMIC addressing utilizes 2 bytes: MSB (byte 1) is base address; LSB (byte 0) is the offset. The range is from bits[15:0] to bits [31:16]. For example, value 0x56781234 would indicate PMIC base address 0x12, offset 0x34 to PMIC base address 0x56, offset 0x78 are inaccessible for a secure HOST.. " />
            <IASecureRdWrInValidAddrRange_1.IASecureRdWrInValidAddrRange_1 value="0x4FCB4FB5" help_text="Secure PMIC Black list Registers for HOST. List of register ranges in PMIC which are subject to write access control. Host does NOT have access to these registers when Secure. PMIC addressing utilizes 2 bytes: MSB (byte 1) is base address; LSB (byte 0) is the offset. The range is from bits[15:0] to bits [31:16]. For example, value 0x56781234 would indicate PMIC base address 0x12, offset 0x34 to PMIC base address 0x56, offset 0x78 are inaccessible for a secure HOST.. " />
            <IASecureRdWrInValidAddrRange_2.IASecureRdWrInValidAddrRange_2 value="0x5E305E30" help_text="Secure PMIC Black list Registers for HOST. List of register ranges in PMIC which are subject to write access control. Host does NOT have access to these registers when Secure. PMIC addressing utilizes 2 bytes: MSB (byte 1) is base address; LSB (byte 0) is the offset. The range is from bits[15:0] to bits [31:16]. For example, value 0x56781234 would indicate PMIC base address 0x12, offset 0x34 to PMIC base address 0x56, offset 0x78 are inaccessible for a secure HOST.. " />
            <IASecureRdWrInValidAddrRange_3.IASecureRdWrInValidAddrRange_3 value="0x5E615E3C" help_text="Secure PMIC Black list Registers for HOST. List of register ranges in PMIC which are subject to write access control. Host does NOT have access to these registers when Secure. PMIC addressing utilizes 2 bytes: MSB (byte 1) is base address; LSB (byte 0) is the offset. The range is from bits[15:0] to bits [31:16]. For example, value 0x56781234 would indicate PMIC base address 0x12, offset 0x34 to PMIC base address 0x56, offset 0x78 are inaccessible for a secure HOST.. " />
            <IASecureRdWrInValidAddrRange_4.IASecureRdWrInValidAddrRange_4 value="0x5E6B5E66" help_text="Secure PMIC Black list Registers for HOST. List of register ranges in PMIC which are subject to write access control. Host does NOT have access to these registers when Secure. PMIC addressing utilizes 2 bytes: MSB (byte 1) is base address; LSB (byte 0) is the offset. The range is from bits[15:0] to bits [31:16]. For example, value 0x56781234 would indicate PMIC base address 0x12, offset 0x34 to PMIC base address 0x56, offset 0x78 are inaccessible for a secure HOST.. " />
            <IASecureRdWrInValidAddrRange_5.IASecureRdWrInValidAddrRange_5 value="0x5FAD5FAC" help_text="Secure PMIC Black list Registers for HOST. List of register ranges in PMIC which are subject to write access control. Host does NOT have access to these registers when Secure. PMIC addressing utilizes 2 bytes: MSB (byte 1) is base address; LSB (byte 0) is the offset. The range is from bits[15:0] to bits [31:16]. For example, value 0x56781234 would indicate PMIC base address 0x12, offset 0x34 to PMIC base address 0x56, offset 0x78 are inaccessible for a secure HOST.. " />
            <IASecureRdWrInValidAddrRange_6.IASecureRdWrInValidAddrRange_6 value="0x6F356F00" help_text="Secure PMIC Black list Registers for HOST. List of register ranges in PMIC which are subject to write access control. Host does NOT have access to these registers when Secure. PMIC addressing utilizes 2 bytes: MSB (byte 1) is base address; LSB (byte 0) is the offset. The range is from bits[15:0] to bits [31:16]. For example, value 0x56781234 would indicate PMIC base address 0x12, offset 0x34 to PMIC base address 0x56, offset 0x78 are inaccessible for a secure HOST.. " />
            <IASecureRdWrInValidAddrRange_7.IASecureRdWrInValidAddrRange_7 value="0x6FDB6FD0" help_text="Secure PMIC Black list Registers for HOST. List of register ranges in PMIC which are subject to write access control. Host does NOT have access to these registers when Secure. PMIC addressing utilizes 2 bytes: MSB (byte 1) is base address; LSB (byte 0) is the offset. The range is from bits[15:0] to bits [31:16]. For example, value 0x56781234 would indicate PMIC base address 0x12, offset 0x34 to PMIC base address 0x56, offset 0x78 are inaccessible for a secure HOST.. " />
            <IASecureRdWrInValidAddrRange_8.IASecureRdWrInValidAddrRange_8 value="0x6FE36FDD" help_text="Secure PMIC Black list Registers for HOST. List of register ranges in PMIC which are subject to write access control. Host does NOT have access to these registers when Secure. PMIC addressing utilizes 2 bytes: MSB (byte 1) is base address; LSB (byte 0) is the offset. The range is from bits[15:0] to bits [31:16]. For example, value 0x56781234 would indicate PMIC base address 0x12, offset 0x34 to PMIC base address 0x56, offset 0x78 are inaccessible for a secure HOST.. " />
            <IASecureRdWrInValidAddrRange_9.IASecureRdWrInValidAddrRange_9 value="0x1A0A1A07" help_text="Secure PMIC Black list Registers for HOST. List of register ranges in PMIC which are subject to write access control. Host does NOT have access to these registers when Secure. PMIC addressing utilizes 2 bytes: MSB (byte 1) is base address; LSB (byte 0) is the offset. The range is from bits[15:0] to bits [31:16]. For example, value 0x56781234 would indicate PMIC base address 0x12, offset 0x34 to PMIC base address 0x56, offset 0x78 are inaccessible for a secure HOST.. " />
            <IASecureRdWrInValidAddrRange_10.IASecureRdWrInValidAddrRange_10 value="0x120A1207" help_text="Secure PMIC Black list Registers for HOST. List of register ranges in PMIC which are subject to write access control. Host does NOT have access to these registers when Secure. PMIC addressing utilizes 2 bytes: MSB (byte 1) is base address; LSB (byte 0) is the offset. The range is from bits[15:0] to bits [31:16]. For example, value 0x56781234 would indicate PMIC base address 0x12, offset 0x34 to PMIC base address 0x56, offset 0x78 are inaccessible for a secure HOST.. " />
            <IASecureRdWrInValidAddrRange_11.IASecureRdWrInValidAddrRange_11 value="0x140A1407" help_text="Secure PMIC Black list Registers for HOST. List of register ranges in PMIC which are subject to write access control. Host does NOT have access to these registers when Secure. PMIC addressing utilizes 2 bytes: MSB (byte 1) is base address; LSB (byte 0) is the offset. The range is from bits[15:0] to bits [31:16]. For example, value 0x56781234 would indicate PMIC base address 0x12, offset 0x34 to PMIC base address 0x56, offset 0x78 are inaccessible for a secure HOST.. " />
            <IASecureRdWrInValidAddrRange_12.IASecureRdWrInValidAddrRange_12 value="0x1C361C35" help_text="Secure PMIC Black list Registers for HOST. List of register ranges in PMIC which are subject to write access control. Host does NOT have access to these registers when Secure. PMIC addressing utilizes 2 bytes: MSB (byte 1) is base address; LSB (byte 0) is the offset. The range is from bits[15:0] to bits [31:16]. For example, value 0x56781234 would indicate PMIC base address 0x12, offset 0x34 to PMIC base address 0x56, offset 0x78 are inaccessible for a secure HOST.. " />
            <IASecureRdWrInValidAddrRange_13.IASecureRdWrInValidAddrRange_13 value="0x00000000" help_text="Secure PMIC Black list Registers for HOST. List of register ranges in PMIC which are subject to write access control. Host does NOT have access to these registers when Secure. PMIC addressing utilizes 2 bytes: MSB (byte 1) is base address; LSB (byte 0) is the offset. The range is from bits[15:0] to bits [31:16]. For example, value 0x56781234 would indicate PMIC base address 0x12, offset 0x34 to PMIC base address 0x56, offset 0x78 are inaccessible for a secure HOST.. " />
            <IASecureRdWrInValidAddrRange_14.IASecureRdWrInValidAddrRange_14 value="0x00000000" help_text="Secure PMIC Black list Registers for HOST. List of register ranges in PMIC which are subject to write access control. Host does NOT have access to these registers when Secure. PMIC addressing utilizes 2 bytes: MSB (byte 1) is base address; LSB (byte 0) is the offset. The range is from bits[15:0] to bits [31:16]. For example, value 0x56781234 would indicate PMIC base address 0x12, offset 0x34 to PMIC base address 0x56, offset 0x78 are inaccessible for a secure HOST.. " />
            <IASecureRdWrInValidAddrRange_15.IASecureRdWrInValidAddrRange_15 value="0x00000000" help_text="Secure PMIC Black list Registers for HOST. List of register ranges in PMIC which are subject to write access control. Host does NOT have access to these registers when Secure. PMIC addressing utilizes 2 bytes: MSB (byte 1) is base address; LSB (byte 0) is the offset. The range is from bits[15:0] to bits [31:16]. For example, value 0x56781234 would indicate PMIC base address 0x12, offset 0x34 to PMIC base address 0x56, offset 0x78 are inaccessible for a secure HOST.. " />
            <IAInsecureRdWrInValidAddrRange_0.IAInSecureRdWrInValidAddrRange_0 value="0x4E924E92" help_text="Note that there are 32 of these such registers, IAInsecureRdWrInvalidAddrRange[32:0]. Insecure PMIC Black list Registers for HOST. List of register ranges in PMIC which are subject to write access control. Host does NOT have access to these registers when Insecure. PMIC addressing utilizes 2 bytes: MSB (byte 1) is base address; LSB (byte 0) is the offset. The range is from bits[15:0] to bits [31:16]. For example, value 0x56781234 would indicate PMIC base address 0x12, offset 0x34 to PMIC base address 0x56, offset 0x78 are inaccessible for an insecure HOST.. " />
            <IAInsecureRdWrInValidAddrRange_1.IAInSecureRdWrInValidAddrRange_1 value="0x4FCB4FB5" help_text="Insecure PMIC Black list Registers for HOST. List of register ranges in PMIC which are subject to write access control. Host does NOT have access to these registers when Insecure. PMIC addressing utilizes 2 bytes: MSB (byte 1) is base address; LSB (byte 0) is the offset. The range is from bits[15:0] to bits [31:16]. For example, value 0x56781234 would indicate PMIC base address 0x12, offset 0x34 to PMIC base address 0x56, offset 0x78 are inaccessible for an insecure HOST.. " />
            <IAInsecureRdWrInValidAddrRange_2.IAInSecureRdWrInValidAddrRange_2 value="0x5E185E16" help_text="Insecure PMIC Black list Registers for HOST. List of register ranges in PMIC which are subject to write access control. Host does NOT have access to these registers when Insecure. PMIC addressing utilizes 2 bytes: MSB (byte 1) is base address; LSB (byte 0) is the offset. The range is from bits[15:0] to bits [31:16]. For example, value 0x56781234 would indicate PMIC base address 0x12, offset 0x34 to PMIC base address 0x56, offset 0x78 are inaccessible for an insecure HOST.. " />
            <IAInsecureRdWrInValidAddrRange_3.IAInSecureRdWrInValidAddrRange_3 value="0x5E235E22" help_text="Insecure PMIC Black list Registers for HOST. List of register ranges in PMIC which are subject to write access control. Host does NOT have access to these registers when Insecure. PMIC addressing utilizes 2 bytes: MSB (byte 1) is base address; LSB (byte 0) is the offset. The range is from bits[15:0] to bits [31:16]. For example, value 0x56781234 would indicate PMIC base address 0x12, offset 0x34 to PMIC base address 0x56, offset 0x78 are inaccessible for an insecure HOST.. " />
            <IAInsecureRdWrInValidAddrRange_4.IAInSecureRdWrInValidAddrRange_4 value="0x5E305E30" help_text="Insecure PMIC Black list Registers for HOST. List of register ranges in PMIC which are subject to write access control. Host does NOT have access to these registers when Insecure. PMIC addressing utilizes 2 bytes: MSB (byte 1) is base address; LSB (byte 0) is the offset. The range is from bits[15:0] to bits [31:16]. For example, value 0x56781234 would indicate PMIC base address 0x12, offset 0x34 to PMIC base address 0x56, offset 0x78 are inaccessible for an insecure HOST.. " />
            <IAInsecureRdWrInValidAddrRange_5.IAInSecureRdWrInValidAddrRange_5 value="0x5E615E3C" help_text="Insecure PMIC Black list Registers for HOST. List of register ranges in PMIC which are subject to write access control. Host does NOT have access to these registers when Insecure. PMIC addressing utilizes 2 bytes: MSB (byte 1) is base address; LSB (byte 0) is the offset. The range is from bits[15:0] to bits [31:16]. For example, value 0x56781234 would indicate PMIC base address 0x12, offset 0x34 to PMIC base address 0x56, offset 0x78 are inaccessible for an insecure HOST.. " />
            <IAInsecureRdWrInValidAddrRange_6.IAInSecureRdWrInValidAddrRange_6 value="0x5E6B5E66" help_text="Insecure PMIC Black list Registers for HOST. List of register ranges in PMIC which are subject to write access control. Host does NOT have access to these registers when Insecure. PMIC addressing utilizes 2 bytes: MSB (byte 1) is base address; LSB (byte 0) is the offset. The range is from bits[15:0] to bits [31:16]. For example, value 0x56781234 would indicate PMIC base address 0x12, offset 0x34 to PMIC base address 0x56, offset 0x78 are inaccessible for an insecure HOST.. " />
            <IAInsecureRdWrInValidAddrRange_7.IAInSecureRdWrInValidAddrRange_7 value="0x5FAD5FAC" help_text="Insecure PMIC Black list Registers for HOST. List of register ranges in PMIC which are subject to write access control. Host does NOT have access to these registers when Insecure. PMIC addressing utilizes 2 bytes: MSB (byte 1) is base address; LSB (byte 0) is the offset. The range is from bits[15:0] to bits [31:16]. For example, value 0x56781234 would indicate PMIC base address 0x12, offset 0x34 to PMIC base address 0x56, offset 0x78 are inaccessible for an insecure HOST.. " />
            <IAInsecureRdWrInValidAddrRange_8.IAInSecureRdWrInValidAddrRange_8 value="0x6F356F00" help_text="Insecure PMIC Black list Registers for HOST. List of register ranges in PMIC which are subject to write access control. Host does NOT have access to these registers when Insecure. PMIC addressing utilizes 2 bytes: MSB (byte 1) is base address; LSB (byte 0) is the offset. The range is from bits[15:0] to bits [31:16]. For example, value 0x56781234 would indicate PMIC base address 0x12, offset 0x34 to PMIC base address 0x56, offset 0x78 are inaccessible for an insecure HOST.. " />
            <IAInsecureRdWrInValidAddrRange_9.IAInSecureRdWrInValidAddrRange_9 value="0x6FDB6FD0" help_text="Insecure PMIC Black list Registers for HOST. List of register ranges in PMIC which are subject to write access control. Host does NOT have access to these registers when Insecure. PMIC addressing utilizes 2 bytes: MSB (byte 1) is base address; LSB (byte 0) is the offset. The range is from bits[15:0] to bits [31:16]. For example, value 0x56781234 would indicate PMIC base address 0x12, offset 0x34 to PMIC base address 0x56, offset 0x78 are inaccessible for an insecure HOST.. " />
            <IAInsecureRdWrInValidAddrRange_10.IAInSecureRdWrInValidAddrRange_10 value="0x6FE36FDD" help_text="Insecure PMIC Black list Registers for HOST. List of register ranges in PMIC which are subject to write access control. Host does NOT have access to these registers when Insecure. PMIC addressing utilizes 2 bytes: MSB (byte 1) is base address; LSB (byte 0) is the offset. The range is from bits[15:0] to bits [31:16]. For example, value 0x56781234 would indicate PMIC base address 0x12, offset 0x34 to PMIC base address 0x56, offset 0x78 are inaccessible for an insecure HOST.. " />
            <IAInsecureRdWrInValidAddrRange_11.IAInSecureRdWrInValidAddrRange_11 value="0x1A0A1A07" help_text="Insecure PMIC Black list Registers for HOST. List of register ranges in PMIC which are subject to write access control. Host does NOT have access to these registers when Insecure. PMIC addressing utilizes 2 bytes: MSB (byte 1) is base address; LSB (byte 0) is the offset. The range is from bits[15:0] to bits [31:16]. For example, value 0x56781234 would indicate PMIC base address 0x12, offset 0x34 to PMIC base address 0x56, offset 0x78 are inaccessible for an insecure HOST.. " />
            <IAInsecureRdWrInValidAddrRange_12.IAInSecureRdWrInValidAddrRange_12 value="0x120A1207" help_text="Insecure PMIC Black list Registers for HOST. List of register ranges in PMIC which are subject to write access control. Host does NOT have access to these registers when Insecure. PMIC addressing utilizes 2 bytes: MSB (byte 1) is base address; LSB (byte 0) is the offset. The range is from bits[15:0] to bits [31:16]. For example, value 0x56781234 would indicate PMIC base address 0x12, offset 0x34 to PMIC base address 0x56, offset 0x78 are inaccessible for an insecure HOST.. " />
            <IAInsecureRdWrInValidAddrRange_13.IAInSecureRdWrInValidAddrRange_13 value="0x140A1407" help_text="Insecure PMIC Black list Registers for HOST. List of register ranges in PMIC which are subject to write access control. Host does NOT have access to these registers when Insecure. PMIC addressing utilizes 2 bytes: MSB (byte 1) is base address; LSB (byte 0) is the offset. The range is from bits[15:0] to bits [31:16]. For example, value 0x56781234 would indicate PMIC base address 0x12, offset 0x34 to PMIC base address 0x56, offset 0x78 are inaccessible for an insecure HOST.. " />
            <IAInsecureRdWrInValidAddrRange_14.IAInSecureRdWrInValidAddrRange_14 value="0x1C361C35" help_text="Insecure PMIC Black list Registers for HOST. List of register ranges in PMIC which are subject to write access control. Host does NOT have access to these registers when Insecure. PMIC addressing utilizes 2 bytes: MSB (byte 1) is base address; LSB (byte 0) is the offset. The range is from bits[15:0] to bits [31:16]. For example, value 0x56781234 would indicate PMIC base address 0x12, offset 0x34 to PMIC base address 0x56, offset 0x78 are inaccessible for an insecure HOST.. " />
            <IAInsecureRdWrInValidAddrRange_15.IAInSecureRdWrInValidAddrRange_15 value="0x00000000" help_text="Insecure PMIC Black list Registers for HOST. List of register ranges in PMIC which are subject to write access control. Host does NOT have access to these registers when Insecure. PMIC addressing utilizes 2 bytes: MSB (byte 1) is base address; LSB (byte 0) is the offset. The range is from bits[15:0] to bits [31:16]. For example, value 0x56781234 would indicate PMIC base address 0x12, offset 0x34 to PMIC base address 0x56, offset 0x78 are inaccessible for an insecure HOST.. " />
            <IAInsecureRdWrInValidAddrRange_16.IAInSecureRdWrInValidAddrRange_16 value="0x00000000" help_text="Insecure PMIC Black list Registers for HOST. List of register ranges in PMIC which are subject to write access control. Host does NOT have access to these registers when Insecure. PMIC addressing utilizes 2 bytes: MSB (byte 1) is base address; LSB (byte 0) is the offset. The range is from bits[15:0] to bits [31:16]. For example, value 0x56781234 would indicate PMIC base address 0x12, offset 0x34 to PMIC base address 0x56, offset 0x78 are inaccessible for an insecure HOST.. " />
            <IAInsecureRdWrInValidAddrRange_17.IAInSecureRdWrInValidAddrRange_17 value="0x00000000" help_text="Insecure PMIC Black list Registers for HOST. List of register ranges in PMIC which are subject to write access control. Host does NOT have access to these registers when Insecure. PMIC addressing utilizes 2 bytes: MSB (byte 1) is base address; LSB (byte 0) is the offset. The range is from bits[15:0] to bits [31:16]. For example, value 0x56781234 would indicate PMIC base address 0x12, offset 0x34 to PMIC base address 0x56, offset 0x78 are inaccessible for an insecure HOST.. " />
            <InsecureWrRegBitMskAddr_0.InsecureWrRegBitMskAddr_0 value="0x03034FD3" help_text="Note that there are 16 of these such registers, InsecureWrRegBitMskAddr[15:0]. Information for bitwise set or clear permissions for the insecure blacklist registers. The data contains the register address (bits[15:8],[7:0] are the device and offset), mask of bits which cannot be SET on a write (bits[23:16]) and mask of bits which cannot be CLEARED on a write (bits[31:24).. " />
            <InsecureWrRegBitMskAddr_1.InsecureWrRegBitMskAddr_1 value="0xFFFD5E24" help_text="Information for bitwise set or clear permissions for the insecure blacklist registers. The data contains the register address (bits[15:8],[7:0] are the device and offset), mask of bits which cannot be SET on a write (bits[23:16]) and mask of bits which cannot be CLEARED on a write (bits[31:24).. " />
            <InsecureWrRegBitMskAddr_2.InsecureWrRegBitMskAddr_2 value="0x00000000" help_text="Information for bitwise set or clear permissions for the insecure blacklist registers. The data contains the register address (bits[15:8],[7:0] are the device and offset), mask of bits which cannot be SET on a write (bits[23:16]) and mask of bits which cannot be CLEARED on a write (bits[31:24).. " />
            <InsecureWrRegBitMskAddr_3.InsecureWrRegBitMskAddr_3 value="0x00000000" help_text="Information for bitwise set or clear permissions for the insecure blacklist registers. The data contains the register address (bits[15:8],[7:0] are the device and offset), mask of bits which cannot be SET on a write (bits[23:16]) and mask of bits which cannot be CLEARED on a write (bits[31:24).. " />
            <InsecureWrRegBitMskAddr_4.InsecureWrRegBitMskAddr_4 value="0x00000000" help_text="Information for bitwise set or clear permissions for the insecure blacklist registers. The data contains the register address (bits[15:8],[7:0] are the device and offset), mask of bits which cannot be SET on a write (bits[23:16]) and mask of bits which cannot be CLEARED on a write (bits[31:24).. " />
            <InsecureWrRegBitMskAddr_5.InsecureWrRegBitMskAddr_5 value="0x00000000" help_text="Information for bitwise set or clear permissions for the insecure blacklist registers. The data contains the register address (bits[15:8],[7:0] are the device and offset), mask of bits which cannot be SET on a write (bits[23:16]) and mask of bits which cannot be CLEARED on a write (bits[31:24).. " />
            <InsecureWrRegBitMskAddr_6.InsecureWrRegBitMskAddr_6 value="0x00000000" help_text="Information for bitwise set or clear permissions for the insecure blacklist registers. The data contains the register address (bits[15:8],[7:0] are the device and offset), mask of bits which cannot be SET on a write (bits[23:16]) and mask of bits which cannot be CLEARED on a write (bits[31:24).. " />
            <InsecureWrRegBitMskAddr_7.InsecureWrRegBitMskAddr_7 value="0x00000000" help_text="Information for bitwise set or clear permissions for the insecure blacklist registers. The data contains the register address (bits[15:8],[7:0] are the device and offset), mask of bits which cannot be SET on a write (bits[23:16]) and mask of bits which cannot be CLEARED on a write (bits[31:24).. " />
            <SecureWrRegBitMskAddr_0.SecureWrRegBitMskAddr_0 value="0x03034FD3" help_text="Note that there are 16 of these such registers, SecureWrRegBitMskAddr[15:0]. Information for bitwise set or clear permissions for the secure blacklist registers. The data contains the register address (bits[15:8],[7:0] are the device and offset), mask of bits which cannot be SET on a write (bits[23:16]) and mask of bits which cannot be CLEARED on a write (bits[31:24).. " />
            <SecureWrRegBitMskAddr_1.SecureWrRegBitMskAddr_1 value="0x00000000" help_text="Information for bitwise set or clear permissions for the secure blacklist registers. The data contains the register address (bits[15:8],[7:0] are the device and offset), mask of bits which cannot be SET on a write (bits[23:16]) and mask of bits which cannot be CLEARED on a write (bits[31:24).. " />
            <SecureWrRegBitMskAddr_2.SecureWrRegBitMskAddr_2 value="0x00000000" help_text="Information for bitwise set or clear permissions for the secure blacklist registers. The data contains the register address (bits[15:8],[7:0] are the device and offset), mask of bits which cannot be SET on a write (bits[23:16]) and mask of bits which cannot be CLEARED on a write (bits[31:24).. " />
            <SecureWrRegBitMskAddr_3.SecureWrRegBitMskAddr_3 value="0x00000000" help_text="Information for bitwise set or clear permissions for the secure blacklist registers. The data contains the register address (bits[15:8],[7:0] are the device and offset), mask of bits which cannot be SET on a write (bits[23:16]) and mask of bits which cannot be CLEARED on a write (bits[31:24).. " />
            <SecureWrRegBitMskAddr_4.SecureWrRegBitMskAddr_4 value="0x00000000" help_text="Information for bitwise set or clear permissions for the secure blacklist registers. The data contains the register address (bits[15:8],[7:0] are the device and offset), mask of bits which cannot be SET on a write (bits[23:16]) and mask of bits which cannot be CLEARED on a write (bits[31:24).. " />
            <SecureWrRegBitMskAddr_5.SecureWrRegBitMskAddr_5 value="0x00000000" help_text="Information for bitwise set or clear permissions for the secure blacklist registers. The data contains the register address (bits[15:8],[7:0] are the device and offset), mask of bits which cannot be SET on a write (bits[23:16]) and mask of bits which cannot be CLEARED on a write (bits[31:24).. " />
            <SecureWrRegBitMskAddr_6.SecureWrRegBitMskAddr_6 value="0x00000000" help_text="Information for bitwise set or clear permissions for the secure blacklist registers. The data contains the register address (bits[15:8],[7:0] are the device and offset), mask of bits which cannot be SET on a write (bits[23:16]) and mask of bits which cannot be CLEARED on a write (bits[31:24).. " />
            <SecureWrRegBitMskAddr_7.SecureWrRegBitMskAddr_7 value="0x00000000" help_text="Information for bitwise set or clear permissions for the secure blacklist registers. The data contains the register address (bits[15:8],[7:0] are the device and offset), mask of bits which cannot be SET on a write (bits[23:16]) and mask of bits which cannot be CLEARED on a write (bits[31:24).. " />
        </WHISKEYCOVE_CATEGORY>
    </PlatformConfiguration>
    <IntelTxeKernel label="Intel(R) TXE Kernel">
        <Processor>
            <ProcEmulation value="No Emulation" value_list="No Emulation,,EMULATE Intel (R) vPro (TM) capable Processor,,EMULATE Intel (R) Core (TM) branded Processor,,EMULATE Intel (R) Celeron (R) branded Processor,,EMULATE Intel (R) Pentium (R) branded Processor,,EMULATE Intel (R) Xeon (R) branded Processor,,EMULATE Intel (R) Xeon (R) Manageability capable Processor" label="Processor Emulation" />
        </Processor>
        <IntelServicesConfiguration label="Intel(R) Services Configuration">
            <OdmIDIntelServices value="0x00000000" label="ODM ID used by Intel(R) Services" help_text="This setting is for entering the ODM ID for Intel(R) Services to identify the ODM Board builder.  Note: This  ID is either generated by or registered with Intel(R ) Services Web servers." />
            <SysIntIdIntelServices value="0x00000000" label="System Integrator ID used by Intel(R) Services" help_text="This setting is for entering the System Integrator ID for Intel(R) Services to identify the System Integrator.  Note: This  ID is either generated by or registered with Intel(R ) Services Web servers." />
            <ReservedIdIntelServices value="0x00000000" label="Reserved ID used by Intel(R) Services" help_text="This setting is for entering the Reserved ID for Intel(R) Services currently not used." />
        </IntelServicesConfiguration>
        <ImageIdentification label="Image Identification">
            <OemTag value="0x00000000" label="OEM Tag" />
        </ImageIdentification>
        <FirmwareDiagnostics label="Firmware Diagnostics">
            <FwAutoBist value="Disabled" value_list="Disabled,,Enabled" label="Automatic Built in Self Test" help_text="This setting enables the firmware Automatic Built in Self Test which is executed during first platform boot after initial image flashing." />
        </FirmwareDiagnostics>
        <DataClearPolicy>
            <DataClearSecurityPolicy value="Token" value_list="OEM,,Token" label="Data Clear Security Policy" help_text="See SPI/SMIP Programming guide for details." />
            <DisableDataClear value="No" value_list="No,,Yes" label="Disable Data Clear" help_text="This setting will disable the 'DATA CLEAR' TXEI command after EOM" />
        </DataClearPolicy>
        <ManufacturingSettings label="Manufacturing Settings">
            <EndOfManufacturing value="No" value_list="No,,Yes" label="End of Manufacturing Enable" help_text="EOM should be set when the image is built in production mode. This will trigger close manuf flows in FW. This setting is not configurable in SPI mode." />
            <PostManufLockEnable value="No" value_list="No,,Yes" label="Post Manufacturing NVAR Configuration Enabled" help_text="This setting determines if modifications to Customer configuable NVARs is to be allowed after close of manufacturing." />
        </ManufacturingSettings>
    </IntelTxeKernel>
    <IsolatedMemoryRanges label="Isolated Memory Ranges">
        <MemoryRanges label="Memory Ranges">
            <Imr00 value="0" help_text="Override IMR size setting. Set to 0 to use default configuration value." />
            <Imr01 value="0" help_text="Override IMR size setting. Set to 0 to use default configuration value." />
            <Imr02 value="0" help_text="Override IMR size setting. Set to 0 to use default configuration value." />
            <Imr03 value="0" help_text="Override IMR size setting. Set to 0 to use default configuration value." />
            <Imr04 value="0" help_text="Override IMR size setting. Set to 0 to use default configuration value." />
            <Imr05 value="0" help_text="Override IMR size setting. Set to 0 to use default configuration value." />
            <Imr06 value="0" help_text="Override IMR size setting. Set to 0 to use default configuration value." />
            <Imr07 value="0" help_text="Override IMR size setting. Set to 0 to use default configuration value." />
            <Imr08 value="0" help_text="Override IMR size setting. Set to 0 to use default configuration value." />
            <Imr09 value="0" help_text="Override IMR size setting. Set to 0 to use default configuration value." />
            <Imr10 value="0" help_text="Override IMR size setting. Set to 0 to use default configuration value." />
            <Imr11 value="0" help_text="Override IMR size setting. Set to 0 to use default configuration value." />
            <Imr12 value="0" help_text="Override IMR size setting. Set to 0 to use default configuration value." />
            <Imr13 value="0" help_text="Override IMR size setting. Set to 0 to use default configuration value." />
            <Imr14 value="0" help_text="Override IMR size setting. Set to 0 to use default configuration value." />
            <Imr15 value="0" help_text="Override IMR size setting. Set to 0 to use default configuration value." />
            <Imr16 value="0" help_text="Override IMR size setting. Set to 0 to use default configuration value." />
            <Imr17 value="0" help_text="Override IMR size setting. Set to 0 to use default configuration value." />
            <Imr18 value="0" help_text="Override IMR size setting. Set to 0 to use default configuration value." />
            <Imr19 value="0" help_text="Override IMR size setting. Set to 0 to use default configuration value." />
        </MemoryRanges>
    </IsolatedMemoryRanges>
    <PlatformProtection label="Platform Protection">
        <ContentProtection label="Content Protection">
            <PavpSupported value="Yes" value_list="No,,Yes" label="PAVP Supported" help_text="This setting determines if the Protected Audio Video Path (PAVP) feature will be permanently disabled in the FW image." />
            <CEKBinary value="" label="Content Encryption Key" help_text="This option is for entering the raw hash 256 bit string or certificate file for the Content Encryption" />
            <Lspcon4kdisp value="None" value_list="None,,PortB,,PortC,,PortD" label="LSPCON Internal Display Port 1 - LSPCON / 4K" help_text="This setting determines which port for LSPCON will be connected to the HDCP 2.2 bridge adapter Display 1." />
            <Hdcp5kedisp1 value="PortA" value_list="None,,PortA,,PortB,,PortC,,PortD" label="HDCP Internal Display Port 1 - 5K" help_text="This setting determines which port  is connected  for 5K output on Internal Display 1.   Note: Both Display 1 &amp; 2 need to be configured for proper operation." />
            <Hdcp5kedisp2 value="None" value_list="None,,PortA,,PortB,,PortC,,PortD" label="HDCP Internal Display Port 2 - 5K" help_text="This setting determines which port  is connected  for 5K output on Internal Display 2. Note: Both Display 1 &amp; 2 need to be configured for proper operation." />
            <VgaPort value="None" value_list="None,,PortA" label="VGA Display Port" help_text="This setting determines if VGA adaptor is configured for port A." />
        </ContentProtection>
        <PlatformIntegrity label="Platform Integrity">
            <SmipSigningKey value="$SourceDir\keys\bxt_dbg_priv_key.pem" label="SMIP Signing Key" help_text="This is the path to the private key used to sign the SMIP, while public key hash of it is included in the OEM hash manifest.  This setting is only configurable when OEM signing is enabled (See PlatformIntegrity/OemPublicKeyHash)." />
            <OemPublicKeyHash value="14 05 A8 A4 EB 1C 8A C2 51 19 7D 85 96 14 09 FF 15 FD CD 23 D3 25 CC DD 88 D2 17 5C DE 3B 27 36" label="OEM Public Key Hash" help_text="Raw hash string for the SHA-256 hash of the OEM public key corresponding to the private key used to sign the OEM Key hash manifest. When manufacture is completed, this hash value is burned into an FPF, and is permament. This value is used to verify the OEM Key hash, and also DnX images. OEM signing is disabled when this hash is set to all 0s." />
            <OemExtInputFile value="$SourceDir\input\oemkeymn2.bin" label="OEM Key Manifest Binary" help_text="Signed manifest file containing hashes of keys used for signing  components of image. This setting is only configurable when OEM signing is enabled (See PlatformIntegrity/OemPublicKeyHash)." />
        </PlatformIntegrity>
        <BootGuardConfiguration label="Boot Guard Configuration">
            <BtGuardKeyManifestId value="0x1" label="Key Manifest ID" help_text="ODM identifier used during the Key manifest authentication process. This setting is only configurable, and must be non-0, when OEM signing is enabled (See PlatformIntegrity/OemPublicKeyHash)." />
            <BtGuardProfileConfig value="Boot Guard Profile 0 - Legacy" value_list="Boot Guard Profile 0 - Legacy,,Boot Guard Profile 1 - V,,Boot Guard Profile 2 - VM" label="Boot Profile" help_text="Boot Guard Profile 0 - Legacy is for platforms that do not wish to enable Boot Guard boot block verification or measurement protection.  Boot Guard Profile 1 - V is Strict Verification Enforcement. Prevents unverified bios components from running.  Boot Guard Profile 2 - VM is Strict Verification and Measurement enforcement. Prevents unverified Bios components from running.   When manufacture is completed, this  value is burned into an FPF, and is permament. This setting is only configurable when OEM signing is enabled (See PlatformIntegrity/OemPublicKeyHash)." />
            <BtGuardS3Optimize value="Enabled" value_list="Enabled,,Disabled" label="S3 Optimization" />
            <BtGuardArbUCode value="Yes" value_list="No,,Yes" label="uCode Anti Rollback Enable" />
            <BtGuardArbOemKeyManifest value="Yes" value_list="No,,Yes" label="OEM Key Manifest Anti Rollback Enable" />
            <BtGuardArbBiosMetadata value="Yes" value_list="No,,Yes" label="Bios Metadata Anti Rollback Enable" />
            <BtGuardArbAndroidOs value="Yes" value_list="No,,Yes" label="Android OS Anti Rollback Enable" />
            <BtGuardArbIUnitFw value="Yes" value_list="No,,Yes" label="IUnit Anti Rollback Enable" />
            <BtGuardArbADspFw value="Yes" value_list="No,,Yes" label="aDSP Anti Rollback Enable" />
            <BtGuardArbIfwi value="Yes" value_list="No,,Yes" label="IFWI Anti Rollback Enable" />
            <BtGuardArbPmc value="Yes" value_list="No,,Yes" label="PMC Anti Rollback Enable" />
        </BootGuardConfiguration>
        <IntelPttConfiguration label="Intel(R) PTT Configuration">
            <PttPwrUpState value="Enabled" value_list="Disabled,,Enabled" label="Intel(R) PTT initial power-up state" />
            <PttSupported value="Yes" value_list="No,,Yes" label="Intel(R) PTT Supported" />
            <PttSupportedHw value="Yes" value_list="No,,Yes" label="Intel(R) PTT Supported [FPF]" help_text="Permenently Enable/Disable PTT FPF" />
            <PttProfile value="PC-Client" value_list="PC-Client,,Automotive-Thin" label="Intel(R) PTT Profile" />
        </IntelPttConfiguration>
        <TpmOverSpiBusConfiguration label="TPM Over SPI Bus Configuration">
            <DiscreteTpmLocation value="LPC" value_list="None,,LPC,,SPI" label="Discrete TPM Location" help_text="Location of discrete TPM" />
            <SpiOverTpmClkFreq value="17MHz" value_list="17MHz,,30MHz,,48MHz,,60MHz,,120MHz" label="TPM Clock Frequency" help_text="This field identifies the serial clock frequency for TPM on SPI. This field is undefined if the TPM on SPI is disabled either by softstrap or fuse. This field is defined with a broad range to support SOC implementations. The listed frequencies are approximate." />
        </TpmOverSpiBusConfiguration>
        <DalAppletSigning label="DAL Applet Signing">
            <OemSigningDalApplet value="No" value_list="No,,Yes" label="Allow OEM Signing of DAL Applets" help_text="FPF that enables OEM signing of DAL applets." />
        </DalAppletSigning>
    </PlatformProtection>
    <Gpio label="GPIO Configuration">
        <ActiveProfile value="Profile 0" value_list="Profile 0" label="Active Profile" help_text="The name of the profile to be used in the output image. Additionally, all profiles will be saved as extra binaries." />
        <GpioProfiles label="GPIO Profiles">
            <GpioProfile name="Profile 0">
                <GpioFeatures label="GPIO Features">
                    <CseOwnedOemPinsFeature label="CSE Owned OEM GPIO Pins">
                        <FeaturePins>
                            <Pin0 enable="Disabled" community="NorthWest" pin="0" mode="Default" />
                            <Pin1 enable="Disabled" community="NorthWest" pin="0" mode="Default" />
                            <Pin2 enable="Disabled" community="NorthWest" pin="0" mode="Default" />
                            <Pin3 enable="Disabled" community="NorthWest" pin="0" mode="Default" />
                            <Pin4 enable="Disabled" community="NorthWest" pin="0" mode="Default" />
                            <Pin5 enable="Disabled" community="NorthWest" pin="0" mode="Default" />
                            <Pin6 enable="Disabled" community="NorthWest" pin="0" mode="Default" />
                            <Pin7 enable="Disabled" community="NorthWest" pin="0" mode="Default" />
                            <Pin8 enable="Disabled" community="NorthWest" pin="0" mode="Default" />
                            <Pin9 enable="Disabled" community="NorthWest" pin="0" mode="Default" />
                            <Pin10 enable="Disabled" community="NorthWest" pin="0" mode="Default" />
                            <Pin11 enable="Disabled" community="NorthWest" pin="0" mode="Default" />
                            <Pin12 enable="Disabled" community="NorthWest" pin="0" mode="Default" />
                            <Pin13 enable="Disabled" community="NorthWest" pin="0" mode="Default" />
                            <Pin14 enable="Disabled" community="NorthWest" pin="0" mode="Default" />
                            <Pin15 enable="Disabled" community="NorthWest" pin="0" mode="Default" />
                            <Pin16 enable="Disabled" community="NorthWest" pin="0" mode="Default" />
                            <Pin17 enable="Disabled" community="NorthWest" pin="0" mode="Default" />
                        </FeaturePins>
                    </CseOwnedOemPinsFeature>
                </GpioFeatures>
                <GpioHostWakeWires>
                    <NorthWake1 enable="Disabled" pin="0" />
                    <NorthWake2 enable="Disabled" pin="0" />
                    <NorthWake3 enable="Disabled" pin="0" />
                    <NorthWake4 enable="Disabled" pin="0" />
                    <NorthWake5 enable="Disabled" pin="0" />
                    <NorthWake6 enable="Disabled" pin="0" />
                    <NorthWake7 enable="Disabled" pin="0" />
                    <NorthWake8 enable="Disabled" pin="0" />
                    <NorthWake9 enable="Disabled" pin="0" />
                    <NorthWake10 enable="Disabled" pin="0" />
                    <NorthWake11 enable="Disabled" pin="0" />
                    <NorthWake12 enable="Disabled" pin="0" />
                    <NorthWake13 enable="Disabled" pin="0" />
                    <NorthWake14 enable="Disabled" pin="0" />
                    <NorthWake15 enable="Disabled" pin="0" />
                    <NorthWake16 enable="Disabled" pin="0" />
                    <NorthWestWake1 enable="Disabled" pin="0" />
                    <NorthWestWake2 enable="Disabled" pin="0" />
                    <NorthWestWake3 enable="Disabled" pin="0" />
                    <NorthWestWake4 enable="Disabled" pin="0" />
                    <NorthWestWake5 enable="Disabled" pin="0" />
                    <NorthWestWake6 enable="Disabled" pin="0" />
                    <NorthWestWake7 enable="Disabled" pin="0" />
                    <NorthWestWake8 enable="Disabled" pin="0" />
                    <NorthWestWake9 enable="Disabled" pin="0" />
                    <NorthWestWake10 enable="Disabled" pin="0" />
                    <NorthWestWake11 enable="Disabled" pin="0" />
                    <NorthWestWake12 enable="Disabled" pin="0" />
                    <NorthWestWake13 enable="Disabled" pin="0" />
                    <NorthWestWake14 enable="Disabled" pin="0" />
                    <NorthWestWake15 enable="Disabled" pin="0" />
                    <NorthWestWake16 enable="Disabled" pin="0" />
                </GpioHostWakeWires>
            </GpioProfile>
        </GpioProfiles>
    </Gpio>
    <IntegratedSensorHub label="Integrated Sensor Hub">
        <IshSupported value="Yes" value_list="No,,Yes" label="Integrated Sensor Hub Supported" help_text="This setting allows customers to permanently disable  ISH FPF on the platform." />
        <IshPowerUpState value="Enabled" value_list="Disabled,,Enabled" label="Integrated Sensor Hub Initial Power State" help_text="This setting allows customers to determine the power up state for ISH." />
        <IshImage label="ISH Image">
            <Length value="0x40000" help_text="Total size (in bytes) of the ISH code partition including reserved space. It is recommended to be at least 256kb." />
            <InputFile value="$SourceDir\input\ISHC.bin" label="Input File" help_text="Path to your ISH firmware binary file." />
        </IshImage>
        <IshData label="ISH Data">
            <PdtBinary value="$SourceDir\input\INTC_pdt_BXT_AOB_BOM_SENSORS" label="PDT Binary File" help_text="Path to your PDT binary file." />
        </IshData>
    </IntegratedSensorHub>
    <IUnit label="iUnit">
        <IUnitSecureTouch label="Secure Touch">
            <IUnitSecureTouch value="Disabled" value_list="Disabled,,Enabled" label="Secure Touch" help_text="If enabled, the CSI streams identified by the CAMERA_MASK register have all pixels replaced by a fixed value (i.e. disable camera)" />
        </IUnitSecureTouch>
        <IUnitSecurityControl label="Security Control">
            <IUnitFWSecureMode value="Enabled" value_list="Disabled,,Enabled" label="Firmware Secure Mode" help_text="If enabled, access blockers in IS and PS are enabled, so as to authenticate camera firmware. Must be enabled for FW authentication flow and execution of authenticated FW." />
            <IUnitDfxSecFeatEnOvrd value="Enabled" value_list="Disabled,,Enabled" label="Dfx Secure Feature En Override" help_text="If enabled, NPK is enabled, else dfxsecure_feature_en signal is checked to see if the NPK feature should be enabled or not." />
        </IUnitSecurityControl>
        <IUnitCameraMask label="Camera Mask">
            <IUnitCameraMask1 value="0x3F" label="Camera Mask 1" help_text="Bit mask that identifies cameras that are subject to secure touch, in CSI port A. 1 indicates camera is subject to secure touch, 0 means it is not." />
            <IUnitCameraMask2 value="0x3F" label="Camera Mask 2" help_text="Bit mask that identifies cameras that are subject to secure touch, in CSI port B. 1 indicates camera is subject to secure touch, 0 means it is not." />
        </IUnitCameraMask>
        <IUnitCSI2PortConfigAB label="CSI2 Port Config AB">
            <IUnitPortIdA value="0x10" label="PORT_ID_A" help_text="Specifies configuration of cameras and data lanes allocated to each camera port, for CSI port A. (MSB not used). The 20-pins of set A can be configured and connected to up to four cameras in the platform using MIPI DPHY protocol. The field PORT_ID_A is used to select the number of cameras (also called ports) and the number of data lanes allocated to each camera port. See IUNIT AE for more information on how to configure this field." />
            <IUnitPortIdB value="0x10" label="PORT_ID_B" help_text="Specifies configuration of cameras and data lanes allocated to each camera port, for CSI port B. (MSB not used). The 12-pins of set B can be configured and connected to either four cameras in the platform using MIPI CPHY protocol OR up to two cameras in the platform using the MIPI DPHY protocol.  See IUNIT AE for more information on how to configure this field." />
        </IUnitCSI2PortConfigAB>
    </IUnit>
    <Debug>
        <Idlm label="IDLM">
            <IdlmBinary value="" label="IDLM Binary" help_text="This allows an IDLM binary to be merged into output image built by Intel (R) FIT" />
        </Idlm>
        <IntelTraceHubTechnology label="Intel(R) Trace Hub Technology">
            <IntelTrcHubBinary value="" label="Intel(R) Trace Hub Binary" help_text="This loads the Intel (R) Trace Hub binary that will be merged into the into the output image generated by the Intel(R) FIT tool." />
            <UtokLength value="0x2000" />
            <UnlockToken value="" label="Unlock Token" help_text="This allows the OEM to input an Unlock Token binary file for closed chassis debug." />
            <NpkPtiDis value="Disabled" value_list="Enabled,,Disabled" label="Early boot NPK" help_text="This configuration allows enabling/disabling NorthPeak logging capability for early boot. By enabling this feature, TXE engine will control GPIO_0 to GPIO_4 pins for PTI. Disable it if you do not wish for TXE to control these GPIOs" />
        </IntelTraceHubTechnology>
        <IntelTxeFirmwareDebuggingOverrides label="Intel(R) TXE Firmware Debugging Overrides">
            <DbgOverridePreProdSi value="0x00000000" label="Debug Override Pre-Production Silicon" help_text="Allows the OEM to control FW features to assist with pre-production platform debugging.  This control has no effect if used on production silicon.  Note: Certain options will do not work when the descriptor is locked (See FW Bring-up Guide for setting details)." />
            <DbgOverrideProdSi value="0x00000000" label="Debug Override Production Silicon" help_text="Allows the OEM to control FW features to assist with production platform debugging.  Note: Certain options will do not work when the descriptor is locked (See FW Bring-up Guide for setting details)." />
            <TxeRomBypassEnable value="No" value_list="No,,Yes" label="Firmware ROM Bypass" />
        </IntelTxeFirmwareDebuggingOverrides>
        <HvmFuseEmulation label="HVM Fuse Emulation">
            <EmulateOverrideSocDevReuseDisabled value="No" value_list="No,,Yes" label="Override SoC Device Reuse HVM fuse value Emulation" help_text="See SPI and SMIP Programming Guide for more information" />
        </HvmFuseEmulation>
    </Debug>
    <Dnx label="Download and Execute">
        <DnxConfiguration label="DnX Configuration">
            <DnxEnabled value="Yes" value_list="Yes,,No" label="DnX Enabled" help_text="DnX permanent enable/disable FPF" />
            <DnxPlatformId value="0" label="Platform ID" help_text="Platform ID that DnX uses to verify the image is suitable for the platform. Before FPFs lock, this field is ignored and DnX will accept any image. After FPS lock, only images with this Platform ID will be accepted by DnX." />
            <DnxOemId value="0" label="OEM ID" help_text="OEM ID that DnX uses to verify the image is suitable for the platform. Before FPFs lock, this field is ignored and DnX will accept any image. After FPF lock, only images with this OEM ID will be accepted by DnX." />
            <DnxLedEnabled value="No" value_list="Yes,,No" label="LED Enabled" help_text="DnX LED Permanently Enabled/Disabled FPF" />
            <BuildEnabled value="Yes" value_list="No,,Yes" help_text="Should Intel FIT build a DnX image" />
            <OutputFileName value="$WorkingDir\dnx_spi.bin" />
            <SigningKey value="$SourceDir\keys\bxt_dbg_priv_key.pem" help_text="The path to the private key to use to sign the DnX image.  This setting is only configurable when OEM signing is enabled (See PlatformIntegrity/OemPublicKeyHash)." />
        </DnxConfiguration>
        <UsbDnxDescriptor label="USB Descriptor">
            <DnxUsbStringDescriptor1 value="" label="USB String Descriptor 1" help_text="Used by ROM to communicate manufacturer string (32 characters) to recovery host. If this descriptor is not defined by OEM, identified by all 0’s, ROM will use default descriptors" />
            <DnxUsbStringDescriptor2 value="" label="USB String Descriptor 2" help_text="Used by ROM to communicate manufacturer string (32 characters) to recovery host. If this descriptor is not defined by OEM, identified by all 0’s, ROM will use default descriptors" />
        </UsbDnxDescriptor>
        <DnxSpiConfiguration label="DnX SPI Regions Configuration">
            <DnxSpiIfwiRegion value="Yes" value_list="No,,Yes" label="Enable DnX SPI Region IFWI" help_text="Enable DnX SPI flash update of IFWI region." />
            <DnxSpiPdrRegion value="Yes" value_list="No,,Yes" label="Enable DnX SPI Region PDR" help_text="Enable DnX SPI flash update of PDR region." />
        </DnxSpiConfiguration>
    </Dnx>
</FitData>
